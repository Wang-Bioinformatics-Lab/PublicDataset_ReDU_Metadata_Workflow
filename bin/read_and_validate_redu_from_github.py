import argparse
import pandas as pd
import glob
import re
import os
import json
from io import StringIO
from REDU_conversion_functions import age_category

def complete_and_fill_REDU_table(df, allowedTerm_dict, add_usi = False, other_allowed_file_extensions = [], attempt_adding_file_extensions = False, **kwargs):
    """
    Completes and fills a REDU table with values based on a dictionary of allowed terms and missing values.

    Args:
    df: A pandas DataFrame containing the initial data.
    allowedTerm_dict: A dictionary containing allowed terms and missing values for each column.

    Returns:
    A DataFrame that has been filled with default values for missing columns,
    with values replaced by the corresponding "missing" value from the dictionary 
    if they are not in the allowed terms or are missing/empty, except for specific columns.
    """

    #prepare UberonOntologyIndex
    if 'UBERONOntologyIndex_table' in kwargs.keys():
        uberon_ontology_table = kwargs['UBERONOntologyIndex_table']
    else:
        uberon_ontology_table = pd.DataFrame(columns=['Label', 'UBERONOntologyIndex'])

    uberon_ontology_table['Label'] = uberon_ontology_table['Label'].astype(str)

    #prepare DOIDOntologyTable
    if 'DOIDOntologyIndex_table' in kwargs.keys():
        doid_ontology_table = kwargs['DOIDOntologyIndex_table']
        if 'UBERONOntologyIndex' in doid_ontology_table.columns:
            doid_ontology_table.rename(columns={'UBERONOntologyIndex': 'DOIDOntologyIndex'}, inplace=True)
    else:
        doid_ontology_table = pd.DataFrame(columns=['Label', 'DOIDOntologyIndex'])
    
    doid_ontology_table['Label'] = doid_ontology_table['Label'].astype(str)

    #prepare environment biome table
    if 'ENVOEnvironmentBiomeIndex_table' in kwargs.keys():
        envome_biome_ontology_table = kwargs['ENVOEnvironmentBiomeIndex_table']
    else:
        envome_biome_ontology_table = pd.DataFrame(columns=['Label', 'ENVOEnvironmentBiomeIndex'])

    envome_biome_ontology_table['Label'] = envome_biome_ontology_table['Label'].astype(str)

    #prepare environment material table
    if 'ENVOEnvironmentMaterialIndex_table' in kwargs.keys():
        envome_material_ontology_table = kwargs['ENVOEnvironmentMaterialIndex_table']
    else:
        envome_material_ontology_table = pd.DataFrame(columns=['Label', 'ENVOEnvironmentMaterialIndex'])

    envome_material_ontology_table['Label'] = envome_material_ontology_table['Label'].astype(str)



    #prepare NCBI table
    if 'NCBIRankDivision_table' in kwargs.keys():
        NCBIRankDivision_table = kwargs['NCBIRankDivision_table']
    else:
        NCBIRankDivision_table = pd.DataFrame(columns=['TaxonID', 'NCBIRank', 'NCBIDivision'])

    NCBIRankDivision_table['TaxonID'] = NCBIRankDivision_table['TaxonID'].astype(str)
    NCBIRankDivision_table['NCBIRank'] = NCBIRankDivision_table['NCBIRank'].astype(str)
    NCBIRankDivision_table['NCBIDivision'] = NCBIRankDivision_table['NCBIDivision'].astype(str)

    # Convert all columns to String
    df = df.astype(str)

    #remove autogenerated columns if present
    keys_to_drop = [key for key, value in allowedTerm_dict.items() if value.get("generate") == "True"]
    columns_to_remove = [col for col in keys_to_drop if col in df.columns]
    df = df.drop(columns=columns_to_remove)


    #Resolve contradictory fields
    if 'SampleType' in df.columns:
        mask = df['SampleType'].str.contains('blank', case=False)
        df.loc[mask, ['NCBITaxonomy', 'UBERONBodyPartName', 'AgeInYears', 'UniqueSubjectID']] = ''

    if 'filename' in df.columns and attempt_adding_file_extensions == True:
        df.loc[df['filename'].str.contains(r'^[^.]+$') & (df['filename'].str.len() >= 1), 'filename'] += '.mzML'
        

    input_columns = set(df.columns)

    # Add missing columns with their respective default missing value from the dictionary or generate values if generate == True
    for key, value in allowedTerm_dict.items():
        if key not in df.columns:
            if value['generate'] == 'False':
                if value['missing'] == 'not allowed':
                    print(f'{key}: MISSING. STOPPING INTERPRETATION!')
                    return pd.DataFrame()
                else:
                    df[key] = value['missing']
                    print(f'{key}: ADDED!')


    for key, value in allowedTerm_dict.items():
        if key in df.columns and value['generate'] == 'False':
            allowed_terms = value['allowed_values']
            missing_value = value['missing']

            # Extract unique values from the DataFrame column
            unique_values = df[key].unique()
            
            # Initialize value_map for each condition
            if key not in ['NCBITaxonomy', 'MassSpectrometer', 'filename'] and len(allowed_terms) > 1:
                # General case for non-specific keys with multiple allowed terms
                value_map = {
                    observed_value: next((allowed for allowed in allowed_terms if allowed.replace(" ", "") == str(observed_value).replace(" ", "")), missing_value)
                    for observed_value in unique_values
                }


            elif key in ['NCBITaxonomy', 'MassSpectrometer']:
                # Specific handling for 'NCBITaxonomy' and 'MassSpectrometer' where direct matching is applied
                value_map = {
                    observed_value: (
                        #prioritizing NCBI ID over taxa name when no match is found
                        observed_value if observed_value in allowed_terms 
                        else next((y for y in allowed_terms if "|" in str(observed_value) and y.split("|")[0] == str(observed_value).split("|")[0]), 
                                next((y for y in allowed_terms if "|" in str(observed_value) and y.split("|")[1] == str(observed_value).split("|")[1]), 
                                    missing_value))
                    ) for observed_value in unique_values
                }
            elif allowed_terms[0] == '00':
                # Handling for terms where '00' indicates a placeholder for any value
                value_map = {x: x if pd.notna(x) and x != "" else missing_value for x in unique_values}
            elif allowed_terms[0] == 'numeric':
                # Numeric handling is kept as is
                df[key] = pd.to_numeric(df[key], errors='coerce').fillna(missing_value).replace("", missing_value)
                continue
            elif allowed_terms[0] == 'numeric|numeric':
                # Handling for numeric ranges split by '|'
                value_map = {
                    x: x if all(part.replace('.', '', 1).isdigit() or part.lstrip('-').replace('.', '', 1).isdigit() for part in str(x).split('|')) else missing_value
                    for x in unique_values
                }
            elif key == 'filename':
                # Specific handling for filenames with allowed extensions
                value_map = {
                    x: x if any(str(x).lower().endswith(ext.lower()) for ext in allowed_terms + other_allowed_file_extensions) 
                    else missing_value 
                    for x in unique_values
                }
            # Apply the mapping for columns, except 'numeric' which is handled separately
            if key != 'numeric':
                df[key] = df[key].map(value_map).fillna(missing_value).replace("", missing_value)
            
            # preparing valuemap for print into log
            filtered_map = {k: v for k, v in value_map.items() if k != v}
            if filtered_map: 
                print(f"{key}:")
                for k, v in filtered_map.items():
                    print(f"  {k}: {v}")



    for key, value in allowedTerm_dict.items():
        if value['generate'] == 'True':
            missing_value = value['missing']
            if key == 'LifeStage':
                df[key] = df.apply(lambda x: age_category(x['AgeInYears']) if x['NCBITaxonomy'] == "9606|Homo sapiens" else value['missing'], axis=1)
            if key == 'UniqueSubjectID':
                df[key] = df.apply(lambda x: str(x['MassiveID']) + '_' + str(x['SubjectIdentifierAsRecorded']) 
                                if x['SubjectIdentifierAsRecorded'] != allowedTerm_dict['SubjectIdentifierAsRecorded']['missing'] 
                                and x['SubjectIdentifierAsRecorded'] != ''
                                and x['SubjectIdentifierAsRecorded'] != 'not applicable' 
                                and not pd.isna(x['SubjectIdentifierAsRecorded']) 
                                else value['missing'], axis=1)
            if key == 'UBERONOntologyIndex':
                df = df.merge(uberon_ontology_table[['Label', 'UBERONOntologyIndex']], left_on='UBERONBodyPartName', right_on='Label', how='left')
                df.drop(columns=['Label'], inplace=True)
            if key == 'DOIDOntologyIndex':
                df = df.merge(doid_ontology_table[['Label', 'DOIDOntologyIndex']], left_on='DOIDCommonName', right_on='Label', how='left')
                df.drop(columns=['Label'], inplace=True)
            if key == 'ENVOEnvironmentBiomeIndex':
                df = df.merge(envome_biome_ontology_table[['Label', 'ENVOEnvironmentBiomeIndex']], left_on='ENVOEnvironmentBiome', right_on='Label', how='left')
                df.drop(columns=['Label'], inplace=True)
            if key == 'ENVOEnvironmentMaterialIndex':
                df = df.merge(envome_material_ontology_table[['Label', 'ENVOEnvironmentMaterialIndex']], left_on='ENVOEnvironmentMaterial', right_on='Label', how='left')
                df.drop(columns=['Label'], inplace=True)
            if key == 'USI' and add_usi == True:
                df['filename'] = df['filename'].apply(process_filename)
                df['USI'] = 'mzspec:' + df['MassiveID'] + ':' + df['filename']
            if key == 'NCBIRank':
                df['TaxonID'] = df['NCBITaxonomy'].apply(lambda x: x.split('|')[0] if '|' in x else 'missing value')
                df['TaxonID'] = df['TaxonID'].astype(str)
                df = pd.merge(df, NCBIRankDivision_table, on='TaxonID', how='left')
                df.drop(columns=['TaxonID'], inplace=True)

                if 'NCBIRank' in df.columns:
                    df['NCBIRank'] = df['NCBIRank'].fillna(missing_value)
                else:
                    df['NCBIRank'] = missing_value

                if 'NCBIDivision' in df.columns:
                    df['NCBIDivision'] = df['NCBIDivision'].fillna(missing_value)
                else:
                    df['NCBIDivision'] = missing_value



    # Ensure the dataframe contains only the columns specified in the dictionary
    keys_to_include = [key for key in allowedTerm_dict.keys() if key != 'USI' or add_usi]

    ignored_columns = input_columns - set(keys_to_include)
    
    for column in ignored_columns:
        print(f"IGNORED:  {column}")

    #remove rows if not enough metadata are present
    def count_non_missing_specific(row, cols):
        return (row[cols] != "missing value").sum()
    
    columns_to_consider = ["SampleType", "SampleTypeSub1", "NCBITaxonomy", "UBERONBodyPartName", "BiologicalSex", 
                           "AgeInYears", "LifeStage", "Country", "HealthStatus", "SampleExtractionMethod", 
                           "SampleCollectionMethod", "ComorbidityListDOIDIndex", "DOIDCommonName", 
                           "DepthorAltitudeMeters", "HumanPopulationDensity", "LatitudeandLongitude",
                           "ENVOEnvironmentBiome", "ENVOEnvironmentMaterial"]
    
    original_row_count = df.shape[0]
    columns_to_check = [col for col in columns_to_consider if col in df.columns]
    df = df[(df.apply(count_non_missing_specific, cols=columns_to_check, axis=1) >= 1)]

    print(f"Number of rows removed due to not enough metadata: {original_row_count - df.shape[0]}")
    print(f"Returning {len(df)} rows!")

    return df[keys_to_include]

def process_filename(filename):
    path_parts = filename.split('/')
    for part in path_parts:
        print(part)
        if part.endswith('.d'):
            return '/'.join(path_parts[:path_parts.index(part)+1])
    return filename


def clean_read_tsv_quoted_lines(path):
    cleaned_data = ''
    with open(path, 'r') as file:
        for line in file:
            # Strip leading and trailing whitespace and then strip double quotes
            cleaned_line = line.strip().strip('"')
            cleaned_data += cleaned_line + '\n'

    # Use StringIO to simulate a file object for pandas
    cleaned_data_io = StringIO(cleaned_data)

    # Now read the cleaned data into a DataFrame
    df = pd.read_csv(cleaned_data_io, sep='\t')

    return df

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='GNPS Validator')
    parser.add_argument('path_to_github_metadata')    
    parser.add_argument('output_metadata_folder')
    parser.add_argument("--AllowedTermJson_path", type=str, help="Path to json with allowed terms")
    parser.add_argument('--path_to_uberon_cl_po_csv')
    parser.add_argument('--path_to_envo_biome_csv')
    parser.add_argument('--path_to_envo_material_csv')
    parser.add_argument('--path_ncbi_rank_division')
    parser.add_argument('--path_to_doid_csv')
    args = parser.parse_args()

    with open(args.AllowedTermJson_path, 'r') as json_file:
        allowed_terms = json.load(json_file)

    uberon_ontology_table = pd.read_csv(args.path_to_uberon_cl_po_csv, index_col=False)
    uberon_ontology_table = uberon_ontology_table.drop_duplicates(subset=['Label'])

    doid_ontology_table = pd.read_csv(args.path_to_doid_csv, index_col=False)
    doid_ontology_table = doid_ontology_table.drop_duplicates(subset=['Label'])

    ENVOEnvironmentBiomeIndex_table = pd.read_csv(args.path_to_envo_biome_csv, index_col=False)
    ENVOEnvironmentBiomeIndex_table = ENVOEnvironmentBiomeIndex_table.drop_duplicates(subset=['Label'])

    ENVOEnvironmentMaterialIndex_table = pd.read_csv(args.path_to_envo_material_csv, index_col=False)
    ENVOEnvironmentMaterialIndex_table = ENVOEnvironmentMaterialIndex_table.drop_duplicates(subset=['Label'])

    NCBIRankDivision_table = pd.read_csv(args.path_ncbi_rank_division, index_col = False)
    NCBIRankDivision_table = NCBIRankDivision_table.drop_duplicates(subset=['TaxonID'])


    print('Starting tsv processing.')
    #for file_path in glob.glob(f"{args.path_to_github_metadata}/redu_*.tsv"):

    all_metadata_files = glob.glob(f"{args.path_to_github_metadata}/*.tsv")

    print("Processing", len(all_metadata_files), "files")
   

    for file_path in all_metadata_files:
    #for file_path in ["/home/yasin/projects/ReDU_metadata/metadata/redu_MSV000093329.tsv"]:
        
        #if re.match(r'.*redu_MSV\d+\.tsv$', file_path):
        if True:

            print(f"Processing: {file_path}")

            df = pd.read_csv(file_path, sep='\t')

            if 'ATTRIBUTE_MassiveID' in df.columns:
                df.rename(columns={'ATTRIBUTE_MassiveID': 'MassiveID'}, inplace=True)
            if 'ATTRIBUTE_DatasetAccession' in df.columns:
                df.rename(columns={'ATTRIBUTE_DatasetAccession': 'MassiveID'}, inplace=True)

            #generate extra columns, add missing columns and remove values which are not in allowed terms
            df = complete_and_fill_REDU_table(df, 
                                              allowed_terms, 
                                              UBERONOntologyIndex_table=uberon_ontology_table, 
                                              DOIDOntologyIndex_table=doid_ontology_table, 
                                              NCBIRankDivision_table=NCBIRankDivision_table,
                                              ENVOEnvironmentBiomeIndex_table=ENVOEnvironmentBiomeIndex_table,
                                              ENVOEnvironmentMaterialIndex_table=ENVOEnvironmentMaterialIndex_table,
                                              attempt_adding_file_extensions=True)
            
            if len(df) > 0:
            
                file_name = os.path.join(args.output_metadata_folder, os.path.basename(file_path))
                df.to_csv(file_name, sep='\t', index=False)
